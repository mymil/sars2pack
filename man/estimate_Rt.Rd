% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate_Rt.R
\name{estimate_Rt}
\alias{estimate_Rt}
\title{Estimate R(t) from cumulative case time series}
\usage{
estimate_Rt(
  df,
  filter_expression,
  cases_column = "count",
  date_column = "date",
  method,
  config,
  cumulative = TRUE,
  estimation_family = "epiestim",
  invert = FALSE,
  quiet = TRUE,
  ...
)
}
\arguments{
\item{df}{a data.frame containing at least a date column and a cases column, describing
the cumulative cases at each date. Note that dates MUST NOT REPEAT and the function
will check that this is the case. Use the \code{filter_expression} parameter to limit
the data.frame to achieve non-duplicated dates from the typical case-tracking datasets
in sars2pack.}

\item{filter_expression}{a \code{dplyr::filter} expression, applied directly to the data.frame
prior to calculating Rt. This is a useful way to write a one-liner from any of the
case-tracking datasets.}

\item{cases_column}{character(1) name of (cumulative) cases column in the input data.frame}

\item{date_column}{character(1) name of date column in the input data.frame}

\item{method}{character(1) passed to \code{EpiEstim::estimate_R()}}

\item{config}{list() passed to \code{EpiEstim::make_config()}. Typically used to
set up the serial interval distribution.}

\item{estimation_family}{One of \code{epiestim}}

\item{invert}{\strong{Unused} default FALSE, but if TRUE, returns 1/R(t) or related
estimate, useful for plotting, since we are often most interested
in looking at R(t) near or below 1.}

\item{quiet}{logical(1) whether or not to provide messages, etc.}

\item{...}{passed to the estimation method}
}
\value{
For the epiestim method, returns a data.frame with columns:
- Mean(R)
- Std(R)
- Quantile.0.025(R)
- Quantile.0.05(R)
- Quantile.0.25(R)
- Median(R)
- Quantile.0.75(R)
- Quantile.0.95(R)
- Quantile.0.975(R)"
- date_start
- date_end
}
\description{
Given a case-tracking dataset, determine the basic reproduction
index over time.
}
\examples{
nyt = nytimes_state_data()
head(nyt)

nystate_Rt = estimate_Rt(
    nyt,
    filter_expression = state=='New York' & subset=='confirmed',
    estimation_family='epiestim',
    cumulative=TRUE,
    method = 'parametric_si',
    config = list(mean_si=3.96, std_si=4.75))
head(nystate_Rt)

library(ggplot2)
p = ggplot(nystate_Rt, aes(x=date_start,y=`Mean(R)`)) + geom_line()
p
p + geom_ribbon(aes(ymin=`Quantile.0.05(R)`, ymax=`Quantile.0.95(R)`), alpha=0.5)

# plot 1/Rt to expand region around 1 since that is typically what
# is most interesting with respect to controls

p = ggplot(nystate_Rt, aes(x=date_start,y=1/`Mean(R)`)) + geom_line()
p
p + geom_ribbon(aes(ymax=1/`Quantile.0.05(R)`, ymin=1/`Quantile.0.95(R)`), alpha=0.5)

# and simple loess smoothing
p + geom_smooth()


# super-cool use of tidyr, purrr, and dplyr to perform 
# calculations over all states:
\dontrun{
library(dplyr)
library(tidyr)
est_by = function(df) {
        estimate_Rt(
        df,
        estimation_family='epiestim',
        cumulative=TRUE,
        method = 'parametric_si',
        config = list(mean_si=3.96, std_si=4.75))
    }
z = nyt \%>\% dplyr::filter(subset=='confirmed') \%>\% tidyr::nest(-state) \%>\%
    dplyr::mutate(rt_df = purrr::map(data, est_by)) \%>\% tidyr::unnest(cols=rt_df)
p = ggplot(z,aes(x=date_start,y=1/`Mean(R)`, color=state)) + 
     ylim(c(0.5,1.25)) + 
     geom_smooth(se = FALSE)
p
library(plotly)
ggplotly(p)
}

}
\seealso{
Other analysis: 
\code{\link{bulk_estimate_Rt}()}

Other case-tracking: 
\code{\link{align_to_baseline}()},
\code{\link{beoutbreakprepared_data}()},
\code{\link{bulk_estimate_Rt}()},
\code{\link{combined_us_cases_data}()},
\code{\link{covidtracker_data}()},
\code{\link{ecdc_data}()},
\code{\link{eu_data_cache_data}()},
\code{\link{jhu_data}()},
\code{\link{nytimes_county_data}()},
\code{\link{owid_data}()},
\code{\link{plot_epicurve}()},
\code{\link{usa_facts_data}()}
}
\concept{analysis}
\concept{case-tracking}
