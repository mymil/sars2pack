% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_epicurve.R
\name{plot_epicurve}
\alias{plot_epicurve}
\title{Plot a (set of) epidemic curve(s)}
\usage{
plot_epicurve(
  df,
  filter_expression,
  date_column = "date",
  case_column = "count",
  ...,
  log = TRUE
)
}
\arguments{
\item{df}{a data frame with columns that include at
least a date column and an integer count column}

\item{filter_expression}{an expression that is passed directly to \code{dplyr::filter()}. This
parameter is a convenience feature since the filtering could also be done easily
outside this function.}

\item{date_column}{character(1) the column name of the \code{date} type column}

\item{case_column}{character(1) the column name of the \verb{count of cases} column}

\item{...}{passed to \code{ggplot2::aes_string()}, useful providing colors or
line types to separate out datasets.}

\item{log}{logical(1) TRUE for log10 based y-scale, FALSE for linear}
}
\description{
\code{plot_epicurve} is a simplifying wrapper around ggplot to
produce curves of cumulative cases versus time. The input
data frame should contain at least:
}
\details{
\itemize{
\item a date column (or any data type that has a natural time order); this will become the x-axis
\item a cumulative \code{count} column; this will become the y-axis
}

An additional common use case is to provide a grouping variable
in the data.frame; specifying \code{color=...} will draw group-specific
curves on the same plot. See examples.
}
\examples{
library(dplyr)


jhu = jhu_data() \%>\% 
    filter(CountryRegion=='China' & subset=='confirmed') \%>\% 
    group_by(CountryRegion,date) \%>\% summarize(count=sum(count))

head(jhu)

jhu \%>\% plot_epicurve(log=FALSE)

# add a title
library(ggplot2)
jhu \%>\% plot_epicurve() + ggtitle('Cumulative cases for China')

# Work with testing data
cc = covidtracker_data() \%>\%
    dplyr::mutate(total_tests = positive+negative) \%>\%
    dplyr::filter(total_tests>0)
head(cc)

plot_epicurve(cc, case_column='total_tests', color='state', log=FALSE) +
    ggtitle('Total tests by state') +
    ggplot2::theme(legend.position='bottom')

# get tests per 100k population
# use the tidycensus package to get
# population data
if(require(tidycensus)) {
    pop = tidycensus::get_estimates(geography='state',product='population') \%>\%
        dplyr::filter(variable=='POP')
    head(pop)
    # fix GEOID column to be 5-digit fips
    pop$GEOID=integer_to_fips(as.integer(pop$GEOID))
    cc_pop = merge(cc,pop, by.x='fips', by.y='GEOID', all.x=FALSE, all.y=FALSE)
    cc_pop = cc_pop \%>\% mutate(tests_per_100k = total_tests/value * 100000)
    plot_epicurve(cc_pop, case_column='tests_per_100k', color='state', log=FALSE) +
        ggtitle('Total tests per 100,000 people') +
        ggplot2::theme(legend.position='bottom')
}

}
\seealso{
Other plotting: 
\code{\link{align_to_baseline}()},
\code{\link{plot_projection}()}

Other case-tracking: 
\code{\link{align_to_baseline}()},
\code{\link{beoutbreakprepared_data}()},
\code{\link{bulk_estimate_Rt}()},
\code{\link{combined_us_cases_data}()},
\code{\link{covidtracker_data}()},
\code{\link{ecdc_data}()},
\code{\link{estimate_Rt}()},
\code{\link{eu_data_cache_data}()},
\code{\link{jhu_data}()},
\code{\link{nytimes_county_data}()},
\code{\link{owid_data}()},
\code{\link{usa_facts_data}()}
}
\concept{case-tracking}
\concept{plotting}
